// Вариант № 8. Динамическая строка.
// Объект класса хранит строку текста и ее длину. 
// Память выделяется динамически, ее размер соответствует длине текста, который надо сохранить. 
// При изменении длины строки осуществлять динамическое перераспределение памяти.


// Данные-члены, типы и количество которых хорошо подходят для хранения и представления соответствующих значений.
// Конструктор по умолчанию, конструктор с параметрами (возможно, не один), конструктор копирования и деструктор. 
// Методы установки значений и вывода значений на экран (использовать потоковый ввод/вывод). 
// Static-счетчик количества существующих объектов класса.
// В подходящих для этого методах, используйте параметры по умолчанию.
// Используйте в конструкторах список инициализации. 

#include <cstring>		// strlen(), memcpy(), memset(), memmove()
#include <stdexcept>	// out_of_range(), invalid_argument()

#include <iostream>

namespace myStringErrors {
	const int NO_ERRORS = 0;
	const int NOT_FAUND = -1;
};

class myString
{
private:
	char* str;
	size_t size;
	static unsigned int objCount;
public:
	myString();
	myString(const char* t, size_t len=0);
	myString(const myString &other);
	myString(const myString &other, size_t pos, size_t len=0);
	~myString();

	size_t getSize() const;
	// size_t strLenght();
	char* getAddr() const;

	void clear();
	bool empty() const;

	myString& append(const myString&, size_t pos=0, size_t len=0);
	myString& append(const char*, size_t n=0);
	myString& append(const char);

	myString& assign(const myString&, size_t subPos=0, size_t subLen=0);
	myString& assign(const char*, size_t n=0);
	myString& assign(const char, size_t n=1);

	myString& insert(size_t pos, const myString& tStr, size_t subPos=0, size_t subLen=0);
	myString& insert(size_t pos, const char* tStr, size_t n=0);
	myString& insert(size_t pos, const char ch, size_t n=1);

	myString& replace(size_t pos, size_t len, const myString& tStr);
	myString& replace(size_t pos, size_t len, const char*);

	myString& replace(const myString& oldStr, const myString& newStr, size_t maxcount=0);
	myString& replace(const char*, const char*, size_t maxcount=0);
	myString& replace(const char, const char, size_t maxcount=0);

	void swap(myString& tStr);

	int count(const myString& subStr, size_t start=0, size_t end=0) const;
	int count(const char* subStr, size_t start=0, size_t end=0) const;
	int count(const char ch, size_t start=0, size_t end=0) const;
	
	int find(const myString& subStr, size_t start=0, size_t end=0) const;
	int find(const char* subStr, size_t start=0, size_t end=0) const;
	int find(const char ch, size_t start=0, size_t end=0) const;

private:
	bool isInThis(const char* p);
public:
	static unsigned int getObjCount();
};


// Форматирование
// center(width)
// 	Возвращает строку длиной width, в центре которой расположена исходная стро-
// 	ка (центрирует строку в поле заданной ширины). Строка дополняется до нужной
// 	длины пробелами. Если width меньше длины исходной строки, она возвращается
// 	без изменений.
// ljust(width)
// 	Возвращает копию исходной строки, дополненную справа пробелами (выравнива-
// 	ет строку влево в поле заданной ширины). Если width меньше длины исходной
// 	строки, она возвращается без изменений.
// rjust(width)
// 	Возвращает копию исходной строки, дополненную слева пробелами (выравнивает
// 	строку вправо в поле заданной ширины). Если width меньше длины исходной
// 	строки, она возвращается без изменений.

// Поиск вхождений
// count(sub [, start [, end]])
// 	Возвращает количество вхождений подстроки sub в s[start:end]. Необязатель-
// 	ные аргументы start и end интерпретируются так же, как и в операции среза
// 	(раздел 11.2).11.2. Последовательности

// endswith(suffix [, start [, end]])
// 	Возвращает 1, если строка s[start:end] заканчивается на suffix, иначе воз-
// 	вращает 0.
// find(sub [, start [, end]])
// 	Возвращает наименьший индекс в исходной строке s начала вхождения подстроки
// 	sub в s[start:end]. Необязательные аргументы start и end интерпретиру-
// 	ются так же, как и в операции среза (раздел 11.2). Если подстрока не найдена,
// 	возвращает -1.
// index(sub [, start [, end]])
// 	Аналог метода find(), генерирующий исключение, если подстрока не найдена.
// rfind(sub [, start [, end]])
// 	Возвращает наибольший индекс в исходной строке s начала вхождения подстроки
// 	sub в s[start:end]. Необязательные аргументы start и end интерпретиру-
// 	ются так же, как и в операции среза (раздел 11.2). Если подстрока не найдена,
// 	возвращает -1.
// rindex(sub [, start [, end]])
// 	Аналог метода rfind(), генерирующий исключение, если подстрока не найдена.
// startswith(prefix [, start [, end]])
// 	Возвращает 1, если строка s[start:end] начинается с prefix, иначе возвра-
// 	щает 0.

// Преобразование символов и фрагментов строк
// expandtabs([tabsize])
// 	Возвращает копию исходной строки, в которой все символы табуляции заменены
// 	одним или несколькими пробелами в зависимости от текущей позиции размера
// 	табуляции. По умолчанию размер табуляции tabsize равен 8 символам.
// lstrip()
// 	Возвращает копию строки, с удаленными идущими в начале строки символами
// 	пропуска (см. метод isspace()).
// replace(old, new [, maxcount])
// 	Возвращает копию строки, в которой все вхождения подстроки old заменены на
// 	new. Если задан необязательный аргумент maxcount, заменяются только первые
// 	maxcount вхождений.
// rstrip()
// 	Возвращает копию строки, с удаленными идущими в конце строки символами про-
// 	пуска (см. метод isspace()).
// strip()
// 	Возвращает копию строки, с удаленными идущими в начале и конце строки сим-
// 	волами пропуска (см. метод isspace()).142

// translate(table [, delchars])
// 	Возвращает копию строки, в которой все символы, указанные в строке delchars
// 	удалены, а для оставшихся символов произведена заменена c ⇒ table[ord(c)].
// 	Аргумент table должен быть строкой из 256 символов. Замечание: у объектов
// 	unicode этот метод имеет другой синтаксис (см. раздел 11.2.2).
// encode([encoding [, errors]])
// 	Возвращает представление строки в кодировке encoding (по умолчанию ASCII).
// 	Аргумент errors (строка) указывает способ обработки ошибок. По умолчанию
// 	используется ’strict’ — если символ не может быть представлен в дан-
// 	ной кодировке, генерируется исключение UnicodeError (класс, производный от
// 	ValueError). Другие возможные значения — ’ignore’ (отсутствующие в ко-
// 	дировке символы удаляются) и ’replace’ (отсутствующие в кодировке символы
// 	заменяются, обычно на символ ‘?’). (Метод encode() в версии 1.6 определен
// 	только для строк Unicode.)

// Разбиение и объединение
// join(seq)
// 	Возвращает объединение строк-элементов последовательности seq, используя
// 	строку s в качестве разделителя. Если последовательность содержит элементы,
// 	которые не являются строками, генерирует исключение ValueError.
// split([sep [, maxcount]])
// 	Возвращает список слов, содержащихся в исходной строке. В качестве раздели-
// 	теля слов используется строка sep, если она не задана или равна None, раз-
// 	делителем слов считаются символы пропуска. Если задан аргумент maxcount и
// 	maxcount >= 0, возвращается список из maxcount первых слов и остатка (таким
// 	образом список будет содержать не более maxcount-1 элементов).
// splitlines([keepends])
// 	Аналог метода split(), использующий в качестве разделителя переход на новую
// 	строку. Символы перехода на новую строку включаются в результат, только если
// задан и является истинным необязательный аргумент keepends.
// Методы, зависящие от национальных установок
// Поведение следующих методов зависит от текущих национальных установок. Вы
// можете изменить их с помощью функции locale.setlocale() (см. описание стан-
// дартного модуля locale). Применительно к строкам Unicode все описанные здесь мето-
// ды работают со всеми символами Unicode, для которых соответствующее преобразование
// однозначно.
// capitalize()
// Возвращает копию строки, в которой первая буква заменена на прописную.11.2. Последовательности
// isdigit()
// Возвращает 1, если строка содержит только цифры, иначе возвращает 0.
// islower()
// Возвращает 1, если строка содержит хотя бы один символ, который может быть
// записан в верхнем и нижнем регистре, и все такие символы в строке находятся в
// нижнем регистре (строчные), иначе возвращает 0.
// isspace()
// Возвращает 1, если строка содержит только символы пропуска (whitespace) —
// пробел, табуляция, перевод на новую строку и т. д., иначе возвращает 0.
// istitle()
// Возвращает 1, если регистр букв в строке соответствует заголовку (строчные бук-
// вы следуют только после символов, которые могут быть записаны в верхнем и
// нижнем регистре, а прописные только после символов, для которых нет понятия
// регистра, и с начала строки), иначе возвращает 0 6 .
// isupper()
// Возвращает 1, если строка содержит хотя бы один символ, который может быть
// записан в верхнем и нижнем регистре, и все такие символы в строке находятся в
// верхнем регистре (прописные), иначе возвращает 0.
// lower()
// Возвращает копию строки, все символы которой приведены к нижнему регистру.
// swapcase()
// Возвращает копию строки, в которой регистр букв изменен с верхнего на нижний
// и наоборот.
// title()
// Возвращает копию строки, в которой регистр букв соответствует заголовку (строч-
// ные буквы следуют только после символов, которые могут быть записаны в верхнем
// и нижнем регистре, а прописные только после символов, для которых нет понятия
// регистра, и с начала строки) 6 .
// upper()
// Возвращает копию строки, все символы которой приведены к верхнему регистру.